# Linklist

链表：用一组**任意**的存储单元存储线性表的数据元素(其中，存储单元可以是连续的，也可以是不连续的)。通过指针将一组存储单元串联在一起。把指针及当前存储单元的值组成的数据元素称为**结点**。

常见的链表有：
* 单链表
* 双链表
* 循环链表（单、双向）

链表与数组的差异、优劣势对比如下：

|  | 数组 | 链表 |
| -------- | -------- | -------- |
| 存储方式  | 数组需要连续内存空间来存储，对内存要求高。<br>假设内存当前总剩余大于申请的内存大小，但没有连续且足够大的内存块，仍然会申请失败 | '指针'串联内存块，总内存足够情况下，不存在申请失败问题 |
| 查找（时间复杂度） | O(1) |O(n)|
| 插入、删除（时间复杂度） | O(n) |O(1)|

【Tip】 和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高。具体使用，需要具体分析。

## ## 单链表和双链表差异

备注：以下时间复杂度为（若存在）遍历操作 + 删除或增加节点（值/指针）的总时间复杂度

|                                                | 单链表                                                       | 双链表                             |
| ---------------------------------------------- | ------------------------------------------------------------ | ---------------------------------- |
| 结构                                           | 只有后继指针next                                             | 有前驱指针prev、后继指针next       |
|                                                |                                                              |                                    |
| 删除结点中“值等于某个给定值”的结点，时间复杂度 | 遍历一遍找到该值，然后删除。O(n)                             | 同单链表。O(n)                     |
| 删除给定指针指向的节点，时间复杂度             | 知道待删除节点指针，删除操作还需要知道其前驱节点，故仍需遍历一遍找到。O(n) | 因为知道前驱、后继，直接删除。O(1) |
|                                                |                                                              |                                    |
| 插入在给定节点之前                             | 遍历一遍找到给定节点的前驱，然后插入。O(n)                   | O(1)                               |
| 插入在给定节点之后                             | 因知道后继节点指针。O(1)                                     | O(1)                               |


## Leetcode

- :star:[0021.merge-two-sorted-lists](https://github.com/zlinna/leetcode-go/tree/master/0021.merge-two-sorted-lists)
- :star:[0206.reverse-linked-list](https://github.com/zlinna/leetcode-go/tree/master/0206.reverse-linked-list)
- :anger:
- :shit:

[>> 返回上一级](../) | [>> 返回主目录](../../)